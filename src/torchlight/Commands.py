import ast
import asyncio
import datetime
import logging
import os
import re
import secrets
import subprocess
import sys
import tempfile
import time
import traceback
from pathlib import Path
from re import Match, Pattern
from typing import Any

import aiohttp
import defusedxml.ElementTree as etree
import geoip2.database
import gtts
import yt_dlp
from translatepy import Translator

from torchlight.AccessManager import AccessManager
from torchlight.AudioManager import AudioManager
from torchlight.Config import Config
from torchlight.Player import Player
from torchlight.PlayerManager import PlayerManager
from torchlight.Torchlight import Torchlight
from torchlight.TriggerManager import TriggerManager
from torchlight.URLInfo import (
    get_audio_format,
    get_first_valid_entry,
    get_url_real_time,
    get_url_text,
    get_url_youtube_info,
    print_url_metadata,
)


class BaseCommand:
    order = 0

    def __init__(
        self,
        torchlight: Torchlight,
        access_manager: AccessManager,
        player_manager: PlayerManager,
        audio_manager: AudioManager,
        trigger_manager: TriggerManager,
    ) -> None:
        self.logger = logging.getLogger(self.__class__.__name__)
        self.torchlight = torchlight
        self.audio_manager = audio_manager
        self.player_manager = player_manager
        self.access_manager = access_manager
        self.trigger_manager = trigger_manager
        self.triggers: list[tuple[str, int] | str | Pattern] = []
        self.level = 0

        self.init_command()

    def get_config(self) -> dict[str, Any]:
        return self.torchlight.config["Command"][self.command_name()]

    def init_command(self) -> None:
        command_config = self.get_config()
        self.level = command_config["level"]
        if "triggers" in command_config:
            for trigger in command_config["triggers"]:
                command = trigger["command"]
                if "starts_with" in trigger and trigger["starts_with"]:
                    self.triggers.append((command, len(command)))
                else:
                    self.triggers.append(command)

    def command_name(self) -> str:
        return self.__class__.__name__

    def check_chat_cooldown(self, player: Player) -> bool:
        if player.chat_cooldown > self.torchlight.loop.time():
            cooldown = player.chat_cooldown - self.torchlight.loop.time()
            self.torchlight.SayPrivate(
                player,
                f"You're on cooldown for the next {cooldown:.1f} seconds.",
            )
            return True
        return False

    def check_disabled(self, player: Player) -> bool:
        level = player.admin.level

        disabled = self.torchlight.disabled
        if disabled and (
            disabled > level or disabled == level and level < self.torchlight.config["AntiSpam"]["ImmunityLevel"]
        ):
            self.torchlight.SayPrivate(player, "Torchlight is currently disabled!")
            return True
        return False

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name)
        return 0

    async def _rfunc(self, line: str, match: Match, player: Player) -> str | int:
        self.logger.debug(sys._getframe().f_code.co_name)
        return 0


class URLFilter(BaseCommand):
    order = 1

    youtube_regex = re.compile(
        r".*?(?:youtube\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\?(?:\S*?&?v\=))|youtu\.be\/)([a-zA-Z0-9_-]{6,11}).*?"
    )

    def __init__(
        self,
        torchlight: Torchlight,
        access_manager: AccessManager,
        player_manager: PlayerManager,
        audio_manager: AudioManager,
        trigger_manager: TriggerManager,
    ) -> None:
        super().__init__(
            torchlight,
            access_manager,
            player_manager,
            audio_manager,
            trigger_manager,
        )
        self.triggers = [
            re.compile(
                r"""(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»â€œâ€â€˜â€™]))""",
                re.IGNORECASE,
            )
        ]
        self.level: int = -1

    async def URLInfo(self, url: str) -> None:
        try:
            await print_url_metadata(url=url, callback=self.torchlight.SayChat)
        except Exception as e:
            self.torchlight.SayChat(f"Error: {str(e)}")
            self.logger.error(traceback.format_exc())

        self.torchlight.last_url = url

    async def URLText(self, url: str) -> str:
        text = ""

        try:
            text = await get_url_text(url=url)
        except Exception as e:
            self.torchlight.SayChat(f"Error: {str(e)}")
            self.logger.error(traceback.format_exc())

        self.torchlight.last_url = url
        return text

    async def _rfunc(self, line: str, match: Match, player: Player) -> str | int:
        url: str = match.groups()[0]
        if not url.startswith("http") and not url.startswith("ftp"):
            url = "http://" + url

        if line.startswith("!yts ") or line.startswith("!yt "):
            return line

        if line.startswith("!dec "):
            text = await self.URLText(url)
            if len(text) > 0:
                return "!dec " + text

        asyncio.ensure_future(self.URLInfo(url))
        return -1


def FormatAccess(config: Config, player: Player) -> str:
    answer = f'#{player.user_id} "{player.name}"({player.unique_id}) is '
    level = str(player.admin.level)
    answer += f"level {level!s} as {player.admin.name}."

    if level in config["AudioLimits"]:
        uses = config["AudioLimits"][level]["Uses"]
        total_time = config["AudioLimits"][level]["TotalTime"]

        if uses >= 0:
            answer += " Uses: {}/{}".format(player.storage["Audio"]["Uses"], uses)
        if total_time >= 0:
            answer += " Time: {}/{}".format(
                round(player.storage["Audio"]["TimeUsed"], 2),
                round(total_time, 2),
            )

    return answer


class Access(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_chat_cooldown(player):
            return -1

        if message[0] == "!access":
            if message[1]:
                return -1

            self.torchlight.SayChat(FormatAccess(self.torchlight.config, player), player)

        return 0


class Who(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        Count = 0
        if message[0] == "!who":
            for targeted_player in self.player_manager.players:
                if targeted_player and message[1].lower() in targeted_player.name.lower():
                    self.torchlight.SayChat(FormatAccess(self.torchlight.config, targeted_player))

                    Count += 1
                    if Count >= 3:
                        break

        elif message[0] == "!whois":
            for admin in self.access_manager.admins:
                if message[1].lower() in admin.name.lower():
                    targeted_player = self.player_manager.FindUniqueID(admin.unique_id)
                    if targeted_player is not None:
                        self.torchlight.SayChat(FormatAccess(self.torchlight.config, targeted_player))
                    else:
                        self.torchlight.SayChat(
                            f'#? "{admin.name}"({admin.unique_id}) is level {admin.level!s} is currently offline.'
                        )

                    Count += 1
                    if Count >= 3:
                        break
        return 0


class WolframAlpha(BaseCommand):
    def Clean(self, text: str) -> str:
        return re.sub(
            "[ ]{2,}",
            " ",
            text.replace(" | ", ": ").replace("\n", " | ").replace("~~", " â‰ˆ "),
        ).strip()

    async def Calculate(self, parameters_json: dict[str, str], player: Player) -> int:
        async with aiohttp.ClientSession() as session:
            resp = await asyncio.wait_for(
                session.get(
                    "http://api.wolframalpha.com/v2/query",
                    params=parameters_json,
                ),
                10,
            )
            if not resp:
                return 1

            data = await asyncio.wait_for(resp.text(), 5)
            if not data:
                return 2

        root = etree.fromstring(data)

        # Find all pods with plaintext answers
        # Filter out None -answers, strip strings and filter out the empty ones
        pods: list[str] = list(
            filter(
                None,
                [p.text.strip() for p in root.findall(".//subpod/plaintext") if p is not None and p.text is not None],
            )
        )

        # no answer pods found, check if there are didyoumeans-elements
        if not pods:
            did_you_means = root.find("didyoumeans")
            # no support for future stuff yet, TODO?
            if not did_you_means:
                # If there's no pods, the question clearly wasn't understood
                self.torchlight.SayChat("Sorry, couldn't understand the question.", player)
                return 3

            options = []
            for did_you_mean in did_you_means:
                options.append(f'"{did_you_mean.text}"')
            line = " or ".join(options)
            line = f"Did you mean {line}?"
            self.torchlight.SayChat(line, player)
            return 0

        # If there's only one pod with text, it's probably the answer
        # example: "integral xÂ²"
        if len(pods) == 1:
            answer = self.Clean(pods[0])
            self.torchlight.SayChat(answer, player)
            return 0

        # If there's multiple pods, first is the question interpretation
        question = self.Clean(pods[0].replace(" | ", " ").replace("\n", " "))
        # and second is the best answer
        answer = self.Clean(pods[1])
        self.torchlight.SayChat(f"{question} = {answer}", player)
        return 0

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if not self.torchlight.config["WolframAPIKey"]:
            self.torchlight.SayPrivate(
                message="WolframAlpha is not configured (API key missing)",
                player=player,
            )
            return 1

        if self.check_chat_cooldown(player):
            return -1

        if self.check_disabled(player):
            return -1

        parameters_json = dict(
            {
                "input": message[1],
                "appid": self.torchlight.config["WolframAPIKey"],
            }
        )
        ret = await self.Calculate(parameters_json, player)
        return ret


class UrbanDictionary(BaseCommand):
    # @profile
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_chat_cooldown(player):
            return -1

        if self.check_disabled(player):
            return -1

        async with aiohttp.ClientSession() as session:
            resp = await asyncio.wait_for(
                session.get(f"https://api.urbandictionary.com/v0/define?term={message[1]}"),
                5,
            )
            if not resp:
                return 1

            data = await asyncio.wait_for(resp.json(), 5)
            if not data:
                return 3

            if "list" not in data or not data["list"]:
                self.torchlight.SayChat(f"[UB] No definition found for: {message[1]}", player)
                return 4

            def print_item(item: dict[str, Any]) -> None:
                self.torchlight.SayChat(
                    "[UD] {word} ({thumbs_up}/{thumbs_down}): {definition}\n{example}".format(**item),
                    player,
                )

            print_item(data["list"][0])

        return 0


class OpenWeather(BaseCommand):
    def __init__(
        self,
        torchlight: Torchlight,
        access_manager: AccessManager,
        player_manager: PlayerManager,
        audio_manager: AudioManager,
        trigger_manager: TriggerManager,
    ) -> None:
        super().__init__(
            torchlight,
            access_manager,
            player_manager,
            audio_manager,
            trigger_manager,
        )
        self.config_folder = self.torchlight.config["GeoIP"]["Path"]
        self.city_filename = self.torchlight.config["GeoIP"]["CityFilename"]
        self.geo_ip = geoip2.database.Reader(f"{self.config_folder}/{self.city_filename}")

    def degreeToCardinal(self, degree: int) -> str:
        directions = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]
        return directions[int(((degree + 22.5) / 45.0) % 8)]

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_chat_cooldown(player):
            return -1

        if self.check_disabled(player):
            return -1

        if not message[1]:
            # Use GeoIP location
            info = self.geo_ip.city(player.address.split(":")[0])
            search = f"lat={info.location.latitude}&lon={info.location.longitude}"
        else:
            search = f"q={message[1]}"

        async with aiohttp.ClientSession() as session:
            resp = await asyncio.wait_for(
                session.get(
                    "https://api.openweathermap.org/data/2.5/weather?APPID={}&units=metric&{}".format(
                        self.torchlight.config["OpenWeatherAPIKey"], search
                    )
                ),
                5,
            )
            if not resp:
                return 2

            data = await asyncio.wait_for(resp.json(), 5)
            if not data:
                return 3

        if data["cod"] != 200:
            self.torchlight.SayPrivate(player, "[OW] {}".format(data["message"]))
            return 5

        if "deg" in data["wind"]:
            windDir = self.degreeToCardinal(data["wind"]["deg"])
        else:
            windDir = "?"

        timezone = "{}{}".format("+" if data["timezone"] > 0 else "", int(data["timezone"] / 3600))
        if data["timezone"] % 3600 != 0:
            timezone += ":{}".format((data["timezone"] % 3600) / 60)

        self.torchlight.SayChat(
            "[{}, {}](UTC{}) {}Â°C ({}/{}) {}: {} | Wind {} {}kph | Clouds: {}%% | Humidity: {}%%".format(
                data["name"],
                data["sys"]["country"],
                timezone,
                data["main"]["temp"],
                data["main"]["temp_min"],
                data["main"]["temp_max"],
                data["weather"][0]["main"],
                data["weather"][0]["description"],
                windDir,
                data["wind"]["speed"],
                data["clouds"]["all"],
                data["main"]["humidity"],
            ),
            player,
        )

        return 0


class WUnderground(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        if not self.torchlight.config["WundergroundAPIKey"]:
            self.torchlight.SayPrivate(
                message="Wunderground is not configured (API key missing)",
                player=player,
            )
            return 1

        if not message[1]:
            # Use IP address
            search = "autoip"
            additional = "?geo_ip={}".format(player.address.split(":")[0])
        else:
            async with aiohttp.ClientSession() as session:
                resp = await asyncio.wait_for(
                    session.get(f"http://autocomplete.wunderground.com/aq?format=JSON&query={message[1]}"),
                    5,
                )
                if not resp:
                    return 2

                try:
                    data = await asyncio.wait_for(resp.json(), 5)
                    if not data:
                        return 3
                except Exception as e:
                    self.logger.error(e)
                    self.torchlight.SayPrivate(
                        message="Failed to retrieve data from the wunderground api",
                        player=player,
                    )
                    return 1

            if not data["RESULTS"]:
                self.torchlight.SayPrivate(player, "[WU] No cities match your search query.")
                return 4

            search = data["RESULTS"][0]["name"]
            additional = ""

        async with aiohttp.ClientSession() as session:
            resp = await asyncio.wait_for(
                session.get(
                    "http://api.wunderground.com/api/{}/conditions/q/{}.json{}".format(
                        self.torchlight.config["WundergroundAPIKey"],
                        search,
                        additional,
                    )
                ),
                5,
            )
            if not resp:
                return 2

            try:
                data = await asyncio.wait_for(resp.json(), 5)
                if not data:
                    return 3
            except Exception as e:
                self.logger.error(e)
                self.torchlight.SayPrivate(
                    message="Failed to retrieve data from the wunderground api",
                    player=player,
                )
                return 1

        if "error" in data["response"]:
            self.torchlight.SayPrivate(
                player,
                "[WU] {}.".format(data["response"]["error"]["description"]),
            )
            return 5

        if "current_observation" not in data:
            choices = ""
            num_results = len(data["response"]["results"])
            for i, result in enumerate(data["response"]["results"]):
                choices += "{}, {}".format(
                    result["city"],
                    result["state"] if result["state"] else result["country_iso3166"],
                )

                if i < num_results - 1:
                    choices += " | "

            self.torchlight.SayPrivate(player, f"[WU] Did you mean: {choices}")
            return 6

        curr_observation = data["current_observation"]

        self.torchlight.SayChat(
            "[{}, {}] {}Â°C ({}F) {} | Wind {} {}kph ({}mph) | Humidity: {}".format(
                curr_observation["display_location"]["city"],
                curr_observation["display_location"]["state"]
                if curr_observation["display_location"]["state"]
                else curr_observation["display_location"]["country_iso3166"],
                curr_observation["temp_c"],
                curr_observation["temp_f"],
                curr_observation["weather"],
                curr_observation["wind_dir"],
                curr_observation["wind_kph"],
                curr_observation["wind_mph"],
                curr_observation["relative_humidity"],
            )
        )

        return 0


class VoteDisable(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.torchlight.disabled:
            self.torchlight.SayPrivate(
                player,
                "Torchlight is already disabled for the duration of this map.",
            )
            return -1

        self.torchlight.disable_votes.add(player.unique_id)

        have = len(self.torchlight.disable_votes)
        needed = self.player_manager.player_count // 5
        if have >= needed:
            self.torchlight.SayChat("Torchlight has been disabled for the duration of this map.")
            self.torchlight.disabled = 6
        else:
            self.torchlight.SayPrivate(
                player,
                f"Torchlight needs {needed - have} more disable votes to be disabled.",
            )

        return 0


class VoiceTrigger(BaseCommand):
    def _setup(self) -> None:
        self.logger.debug(sys._getframe().f_code.co_name)
        for trigger in self.trigger_manager.voice_triggers.keys():
            self.triggers.append(trigger)

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_disabled(player):
            return -1

        voice_trigger = message[0].lower()
        trigger_number = message[1].lower()

        sound = self.get_sound_path(
            player=player,
            voice_trigger=voice_trigger,
            trigger_number=trigger_number,
        )

        if not sound:
            return 1

        sound_path = os.path.abspath(
            os.path.join(
                self.trigger_manager.sound_path,
                sound,
            )
        )
        audio_clip = self.audio_manager.AudioClip(player, Path(sound_path).absolute().as_uri())
        if not audio_clip:
            return 1

        return audio_clip.Play()

    def get_sound_path(self, player: Player, voice_trigger: str, trigger_number: str) -> str | None:
        """
        Get sound path for a voice trigger with proper access level checks.

        Args:
            player: Player making the request
            voice_trigger: The trigger command (e.g., "_legend", "!test", "#tempest")
            trigger_number: Optional number or search term for lists

        Returns:
            Sound file path or None if not allowed/not found
        """
        if voice_trigger not in self.trigger_manager.voice_triggers:
            return None

        player_level = player.admin.level
        reserved_level = self.torchlight.config["Command"]["VoiceTriggerReserved"]["level"]
        prefix = voice_trigger[0]
        reserved_prefixes = ["_", "#"]
        if prefix in reserved_prefixes:
            if player_level < reserved_level:
                self.torchlight.SayPrivate(
                    player,
                    f"Trigger '{voice_trigger}' requires level {reserved_level} or higher. "
                    f"Your current level is {player_level}.",
                )
                return None

        voice_trigger_level = self.torchlight.config["Command"]["VoiceTrigger"]["level"]
        if player_level < voice_trigger_level:
            self.torchlight.SayPrivate(
                player,
                f"Voice triggers require level {voice_trigger_level} or higher. Your current level is {player_level}.",
            )
            return None

        sounds = self.trigger_manager.voice_triggers[voice_trigger]

        try:
            num = int(trigger_number) if trigger_number else None
        except ValueError:
            num = None

        if isinstance(sounds, list):
            return self._handle_sound_list(player, voice_trigger, sounds, trigger_number, num)
        else:
            return sounds

    def _handle_sound_list(
        self, player: Player, voice_trigger: str, sounds: list[str], trigger_input: str, num: int | None
    ) -> str | None:
        """
        Handle selection from a list of sounds.

        Args:
            player: Player making the request
            voice_trigger: The trigger command
            sounds: List of sound file paths
            trigger_input: User input (number or search term)
            num: Parsed number if input was numeric

        Returns:
            Selected sound file path or None
        """
        if num is not None:
            if 1 <= num <= len(sounds):
                return sounds[num - 1]
            else:
                self.torchlight.SayPrivate(
                    player, f"Number {num} is out of range. Choose 1-{len(sounds)} for '{voice_trigger}'."
                )
                return None

        if trigger_input:
            return self._search_sound_list(player, voice_trigger, sounds, trigger_input)

        return secrets.choice(sounds)

    def _search_sound_list(self, player: Player, voice_trigger: str, sounds: list[str], search_term: str) -> str | None:
        """
        Search through sound list by filename.

        Args:
            player: Player making the request
            voice_trigger: The trigger command
            sounds: List of sound file paths
            search_term: Search term (with optional ? prefix for search-only)

        Returns:
            Matching sound file path or None
        """
        is_search_only = search_term.startswith("?")
        actual_search = search_term[1:] if is_search_only else search_term

        sound_names = []
        matches = []

        for sound_path in sounds:
            sound_name = os.path.splitext(os.path.basename(sound_path))[0]
            sound_names.append(sound_name)

            if actual_search and actual_search.lower() in sound_name.lower():
                matches.append((sound_name, sound_path))

        if matches:
            matches.sort(key=lambda t: len(t[0]))
            match_names = [name for name, _ in matches]
            if is_search_only:
                self.torchlight.SayPrivate(
                    player,
                    f"Found {len(matches)} matches for '{actual_search}' in '{voice_trigger}': "
                    f"{', '.join(match_names[:10])}",
                )
                return None

            best_match = matches[0][1]
            if len(matches) > 1:
                self.torchlight.SayPrivate(
                    player,
                    f"Multiple matches found for '{actual_search}': {', '.join(match_names[:5])}. "
                    f"Using '{match_names[0]}'.",
                )

            return best_match

        if not is_search_only:
            self.torchlight.SayPrivate(player, f"No matches found for '{actual_search}' in '{voice_trigger}'.")

        self.torchlight.SayPrivate(
            player,
            f"Available sounds for '{voice_trigger}': {', '.join(sound_names[:15])}"
            + ("..." if len(sound_names) > 15 else ""),
        )

        return None


class Random(VoiceTrigger):
    def get_sound_path(self, player: Player, voice_trigger: str, trigger_number: str) -> str | None:
        trigger = secrets.choice(list(self.trigger_manager.voice_triggers.values()))
        if isinstance(trigger, list):
            return secrets.choice(trigger)
        return trigger


class Search(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        voice_trigger = message[1].lower()

        res = []
        for key in self.trigger_manager.voice_triggers.keys():
            if voice_trigger in key.lower():
                res.append(key)
        self.torchlight.SayPrivate(player, "{} results: {}".format(len(res), ", ".join(res)))
        return 0


class PlayMusic(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_disabled(player):
            return -1

        if self.torchlight.last_url:
            message[1] = message[1].replace("!last", self.torchlight.last_url)

        url = message[1]
        if URLFilter.youtube_regex.search(url):
            try:
                command_config = self.torchlight.config["Command"]["YouTubeSearch"]
                proxy = command_config.get("parameters", {}).get("proxy", "")
                cookies = command_config.get("parameters", {}).get("cookies", None)

                ydl_opts = {
                    "quiet": True,
                    "no_warnings": True,
                    "extract_flat": False,
                    "skip_download": True,
                    "forceurl": True,
                    "format": "bestaudio/best",
                    "source_address": "0.0.0.0",  # noqa: S104 - Required for yt-dlp to bind to all interfaces
                }

                if proxy:
                    ydl_opts["proxy"] = proxy
                if cookies:
                    ydl_opts["cookiefile"] = cookies

                ydl = yt_dlp.YoutubeDL(ydl_opts)

                loop = asyncio.get_event_loop()
                info = await loop.run_in_executor(None, lambda: ydl.extract_info(url, download=False))

                if info and "url" in info:
                    audio_url = info["url"]
                    self.torchlight.SayChat(f"Found: {info.get('title', 'Unknown')}")
                    url = audio_url
            except Exception as e:
                self.logger.error(f"Error extracting YouTube URL: {e}")

        real_time = get_url_real_time(url=url)
        audio_clip = self.audio_manager.AudioClip(player, url)
        if not audio_clip:
            return 1

        return audio_clip.Play(real_time)


class YouTubeSearch(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_disabled(player):
            return -1

        command_config = self.get_config()
        proxy = command_config.get("parameters", {}).get("proxy", "")
        cookies = command_config.get("parameters", {}).get("cookies", None)

        input_keywords = message[1]

        if URLFilter.youtube_regex.search(input_keywords):
            input_url = input_keywords
        else:
            input_url = f"ytsearch:{input_keywords}"

        real_time = get_url_real_time(url=input_url)

        try:
            cookies_path = None
            if cookies and os.path.exists(cookies):
                cookies_path = cookies
                self.logger.info(f"Using cookies from: {cookies_path}")

            info = get_url_youtube_info(url=input_url, proxy=proxy, cookies=cookies_path)
        except Exception as exc:
            self.logger.error(f"Failed to extract youtube info from: {input_url}")
            self.logger.error(exc)
            self.torchlight.SayPrivate(
                player,
                "Error retrieving YouTube metadata.",
            )
            return 1

        if "title" not in info and "url" in info:
            info = get_url_youtube_info(url=info["url"], proxy=proxy, cookies=cookies_path)
        if info.get("extractor_key") == "YoutubeSearch":
            info = get_first_valid_entry(entries=info["entries"], proxy=proxy, cookies=cookies_path)

        title = info["title"]
        url = get_audio_format(info=info)
        title_words = title.split()
        keywords_banned: list[str] = []

        if "parameters" in command_config and "keywords_banned" in command_config["parameters"]:
            keywords_banned = command_config["parameters"]["keywords_banned"]

        for keyword_banned in keywords_banned:
            for title_word in title_words:
                if keyword_banned.lower() in title_word.lower():
                    self.torchlight.SayChat(
                        f"{{darkred}}[YouTube]{{default}} {title} has been flagged as inappropriate content, skipping"
                    )
                    return 1

        duration = str(datetime.timedelta(seconds=info["duration"]))
        views = int(info["view_count"])
        self.torchlight.SayChat(f"{{darkred}}[YouTube]{{default}} {title} | {duration} | {views}")

        if cookies and os.path.exists(cookies):
            config_dir = os.path.dirname(cookies)
            torchlight_root = os.path.dirname(config_dir)
        else:
            current_file = os.path.abspath(__file__)
            if "src/torchlight" in current_file:
                torchlight_root = os.path.dirname(os.path.dirname(current_file))
            else:
                torchlight_root = os.getcwd()

        downloads_dir = os.path.join(torchlight_root, "downloads")
        os.makedirs(downloads_dir, exist_ok=True)

        video_id = info.get("id", "unknown")
        timestamp = int(time.time())

        safe_title = "".join(c for c in title if c.isalnum() or c in (" ", "-", "_", ".", "(", ")", "ï½œ")).strip()
        safe_title = safe_title[:100]
        output_template = os.path.join(downloads_dir, f"{safe_title}.%(ext)s")
        temp_path = output_template.replace("%(ext)s", "mp3")

        self.logger.info(f"Will download to: {output_template}")
        self.torchlight.SayChat("{darkblue}[Torchlight]{default} Downloading audio...", player)

        try:
            cmd = [
                "yt-dlp",
                "--js-runtime",
                "node",
                "--remote-components",
                "ejs:github",
                "-f",
                "bestaudio",
                "-x",
                "--audio-format",
                "mp3",
                "--audio-quality",
                "192",
                "--embed-metadata",
                "--embed-thumbnail",
                "--no-playlist",
                "--no-warnings",
                "-o",
                output_template,
                url,
            ]

            if cookies_path:
                cmd.insert(1, "--cookies")
                cmd.insert(2, cookies_path)
                self.logger.info("ðŸª Using cookies file")

            if proxy:
                cmd.extend(["--proxy", proxy])

            youtube_url = info.get("webpage_url", info.get("url", ""))
            if not youtube_url:
                self.logger.error("No YouTube URL found in info")
                self.torchlight.SayPrivate(player, "Error: No YouTube URL found.")
                return 1

            cmd.append(youtube_url)

            self.logger.info(f"Running command: {' '.join(cmd[:12])}...")

            process = await asyncio.create_subprocess_exec(*cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

            output_lines = []
            converting_to_mp3 = False

            while True:
                line = await process.stdout.readline()
                if not line:
                    break
                line_str = line.decode("utf-8", errors="ignore").strip()
                if line_str:
                    output_lines.append(line_str)
                    print(f"  {line_str}")

                    if "[download]" in line_str and ".webm" in line_str:
                        self.logger.info("ðŸ“¥ Webm download started...")

                    if "[ExtractAudio]" in line_str:
                        self.logger.info("ðŸ”§ Converting webm to mp3...")
                        converting_to_mp3 = True

            await process.wait()

            if converting_to_mp3:
                self.logger.info("â³ Waiting for mp3 conversion to complete...")
                for i in range(30):
                    if os.path.exists(temp_path):
                        await asyncio.sleep(1)
                        file_size = os.path.getsize(temp_path)
                        if file_size > 100000:
                            self.logger.info(f"âœ… MP3 ready after {i + 1} seconds")
                            break
                    await asyncio.sleep(1)

            await asyncio.sleep(2)
            found_file = None
            for ext in [".mp3", ".webm", ".m4a"]:
                test_path = output_template.replace("%(ext)s", ext)
                if os.path.exists(test_path):
                    found_file = test_path
                    break

            if not found_file:
                base_name = output_template.replace("%(ext)s", "")
                for filename in os.listdir(downloads_dir):
                    if os.path.basename(base_name) in filename:
                        found_file = os.path.join(downloads_dir, filename)
                        break

            if found_file and os.path.exists(found_file):
                file_size = os.path.getsize(found_file)
                if file_size == 0:
                    self.logger.error(f"File is empty: {found_file}")
                    self.torchlight.SayPrivate(player, "Download failed: File is empty.")
                    try:
                        os.unlink(found_file)
                    except Exception as e:
                        self.logger.debug(f"Failed to delete empty file {found_file}: {e}")
                        pass
                    return 1

                if not found_file.endswith(".mp3"):
                    mp3_path = found_file.rsplit(".", 1)[0] + ".mp3"
                    success = await self._convert_to_mp3(found_file, mp3_path)
                    if success:
                        found_file = mp3_path
                    else:
                        return 1

                file_size = os.path.getsize(found_file)
                file_size_mb = file_size / 1024 / 1024
                self.logger.info(f"Downloaded {file_size_mb:.1f}MB to {found_file}")

                size_str = f"{file_size_mb:.1f}MB" if file_size_mb >= 1 else f"{file_size / 1024:.0f}KB"
                self.torchlight.SayChat(
                    f"{{darkgreen}}[Torchlight]{{default}} Downloaded ({size_str})! Playing now...", player
                )

                audio_clip = self.audio_manager.AudioClip(player, f"file://{found_file}")
                if not audio_clip:
                    self.logger.error(f"Failed to create audio clip for {found_file}")
                    self.torchlight.SayPrivate(player, "Failed to create audio clip for playback.")
                    try:
                        os.unlink(found_file)
                    except Exception as e:
                        self.logger.debug(f"Failed to delete file after playback failure {found_file}: {e}")
                        pass
                    return 1

                def cleanup_temp_file():
                    async def delayed_cleanup():
                        await asyncio.sleep(5)
                        try:
                            if os.path.exists(found_file):
                                os.unlink(found_file)
                                self.logger.info(f"Cleaned up: {found_file}")
                            base = found_file.rsplit(".", 1)[0]
                            for ext in [".webm", ".webp", ".jpg", ".png"]:
                                related = base + ext
                                if os.path.exists(related):
                                    os.unlink(related)
                            self._cleanup_old_files(downloads_dir, keep_last=10)
                        except Exception as e:
                            self.logger.error(f"Cleanup failed: {e}")

                    asyncio.ensure_future(delayed_cleanup())

                audio_clip.audio_player.AddCallback("Stop", cleanup_temp_file)

                self.torchlight.last_url = url
                result = audio_clip.Play(real_time)
                if result:
                    return result
                else:
                    self.logger.error(f"Play failed for {found_file}")
                    self.torchlight.SayPrivate(player, "Playback failed.")
                    try:
                        os.unlink(found_file)
                    except Exception as e:
                        self.logger.debug(f"Failed to delete file after audio clip creation failure {found_file}: {e}")
                        pass
                    return 1

            else:
                self.logger.error("No file created. Process output:")
                for line in output_lines[-10:]:
                    self.logger.error(f"  {line}")
                self.torchlight.SayPrivate(player, "Download failed: No file created.")
                return 1

        except Exception as e:
            self.logger.error(f"Error downloading/playing YouTube audio: {type(e).__name__}: {e}")
            import traceback

            traceback.print_exc()
            self.torchlight.SayPrivate(player, f"Error: {str(e)[:100]}")

            try:
                if "found_file" in locals() and os.path.exists(found_file):
                    os.unlink(found_file)
            except Exception as e:
                self.logger.debug(f"Failed to delete file in exception handler {found_file}: {e}")
                pass

            return 1

    async def _convert_to_mp3(self, input_path: str, output_path: str) -> bool:
        """Convert any audio file to mp3"""
        try:
            self.logger.info(f"Converting {input_path} to mp3...")

            cmd = [
                "ffmpeg",
                "-i",
                input_path,
                "-vn",
                "-ar",
                "48000",
                "-ac",
                "2",
                "-b:a",
                "192k",
                "-f",
                "mp3",
                output_path,
                "-y",
            ]

            process = await asyncio.create_subprocess_exec(*cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            await process.communicate()

            if os.path.exists(output_path) and os.path.getsize(output_path) > 100000:
                try:
                    os.unlink(input_path)
                except Exception as e:
                    self.logger.debug(f"Failed to delete input file after conversion {input_path}: {e}")
                    pass
                return True

        except Exception as e:
            self.logger.error(f"Conversion failed: {e}")

        return False

    def _cleanup_old_files(self, directory: str, keep_last: int = 10):
        """Clean up old files, keeping only the most recent ones"""
        try:
            files = []
            for filename in os.listdir(directory):
                filepath = os.path.join(directory, filename)
                if os.path.isfile(filepath):
                    files.append((filepath, os.path.getmtime(filepath)))
            files.sort(key=lambda x: x[1], reverse=True)
            for filepath, _ in files[keep_last:]:
                try:
                    os.unlink(filepath)
                    self.logger.info(f"Cleaned up old file: {os.path.basename(filepath)}")
                except Exception as e:
                    self.logger.error(f"Failed to delete old file {filepath}: {e}")

        except Exception as e:
            self.logger.error(f"Error cleaning up old files: {e}")


class Say(BaseCommand):
    try:
        VALID_LANGUAGES = [lang for lang in gtts.lang.tts_langs().keys()]
    except Exception:
        VALID_LANGUAGES = [
            "af",
            "ar",
            "bn",
            "bs",
            "ca",
            "cs",
            "cy",
            "da",
            "de",
            "el",
            "en",
            "eo",
            "es",
            "et",
            "fi",
            "fr",
            "gu",
            "hi",
            "hr",
            "hu",
            "hy",
            "id",
            "is",
            "it",
            "ja",
            "jw",
            "km",
            "kn",
            "ko",
            "la",
            "lv",
            "mk",
            "ml",
            "mr",
            "my",
            "ne",
            "nl",
            "no",
            "pl",
            "pt",
            "ro",
            "ru",
            "si",
            "sk",
            "sq",
            "sr",
            "su",
            "sv",
            "sw",
            "ta",
            "te",
            "th",
            "tl",
            "tr",
            "uk",
            "ur",
            "vi",
            "zh-CN",
            "zh-TW",
            "zh",
        ]

    def collapse_repeated_vowels(self, text: str) -> str:
        # Replace sequences of 2 or more vowels with a single vowel
        return re.sub(r"([aeiouyAEIOUY])\1{1,}", r"\1", text)

    async def Say(self, player: Player, language: str, tld: str, message: str) -> int:
        # Collapse repeated vowels before passing to gTTS
        # message = self.collapse_repeated_vowels(message)
        google_text_to_speech = gtts.gTTS(text=message, tld=tld, lang=language, lang_check=False)

        temp_file = tempfile.NamedTemporaryFile(delete=False)
        google_text_to_speech.write_to_fp(temp_file)
        temp_file.close()

        audio_clip = self.audio_manager.AudioClip(player, Path(temp_file.name).absolute().as_uri())
        if not audio_clip:
            os.unlink(temp_file.name)
            return 1

        if audio_clip.Play():
            audio_clip.audio_player.AddCallback("Stop", lambda: os.unlink(temp_file.name))
            return 0
        else:
            os.unlink(temp_file.name)
            return 1

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_disabled(player):
            return -1

        if not message[1]:
            return 1

        language: str = ""
        tld: str = "com"

        command_config = self.get_config()
        if "parameters" in command_config and "default" in command_config["parameters"]:
            if "language" in command_config["parameters"]["default"]:
                language = command_config["parameters"]["default"]["language"]
            if "tld" in command_config["parameters"]["default"]:
                tld = command_config["parameters"]["default"]["tld"]

        if len(message[0]) > 4:
            language = message[0][4:]

        self.logger.debug(f"{language}: {self.VALID_LANGUAGES}")
        if len(language) <= 0 or language not in self.VALID_LANGUAGES:
            return 1

        asyncio.ensure_future(self.Say(player, language, tld, message[1]))
        return 0


class TranslateSay(BaseCommand):
    try:
        VALID_LANGUAGES = list(gtts.lang.tts_langs().keys())
    except Exception:
        VALID_LANGUAGES = [
            "af",
            "ar",
            "bn",
            "bs",
            "ca",
            "cs",
            "cy",
            "da",
            "de",
            "el",
            "en",
            "eo",
            "es",
            "et",
            "fi",
            "fr",
            "gu",
            "hi",
            "hr",
            "hu",
            "hy",
            "id",
            "is",
            "it",
            "ja",
            "jw",
            "km",
            "kn",
            "ko",
            "la",
            "lv",
            "mk",
            "ml",
            "mr",
            "my",
            "ne",
            "nl",
            "no",
            "pl",
            "pt",
            "ro",
            "ru",
            "si",
            "sk",
            "sq",
            "sr",
            "su",
            "sv",
            "sw",
            "ta",
            "te",
            "th",
            "tl",
            "tr",
            "uk",
            "ur",
            "vi",
            "zh-CN",
            "zh-TW",
            "zh",
        ]

    def __init__(self, torchlight, access_manager, player_manager, audio_manager, trigger_manager):
        super().__init__(torchlight, access_manager, player_manager, audio_manager, trigger_manager)

        self.translator = Translator()
        self.triggers = [f"!tsay{lang}" for lang in self.VALID_LANGUAGES]

    async def TranslateAndSay(self, player, target_lang: str, tld: str, message: str) -> int:

        supported_langs = gtts.lang.tts_langs()

        if target_lang not in supported_langs:
            self.torchlight.SayPrivate(player, f"Sorry, TTS for '{target_lang}' is not supported.")
            return 1

        # ----------------------------------------------------------
        # 1. Translate text using TranslatePy
        # ----------------------------------------------------------
        try:
            translated = await asyncio.get_event_loop().run_in_executor(
                None, lambda: self.translator.translate(message, target_lang)
            )
            translated_text = translated.result  # TranslatePy uses .result
        except Exception as e:
            self.torchlight.SayPrivate(player, f"Translation failed: {e}")
            return 1

        # ----------------------------------------------------------
        # 2. Generate TTS from translated text
        # ----------------------------------------------------------
        try:
            tts = gtts.gTTS(text=translated_text, lang=target_lang, tld=tld, lang_check=False)
            temp_file = tempfile.NamedTemporaryFile(delete=False)
            tts.write_to_fp(temp_file)
            temp_file.close()
        except Exception as e:
            self.torchlight.SayPrivate(player, f"TTS failed: {e}")
            return 1

        # ----------------------------------------------------------
        # 3. Play audio
        # ----------------------------------------------------------
        audio_clip = self.audio_manager.AudioClip(player, Path(temp_file.name).absolute().as_uri())

        if not audio_clip:
            os.unlink(temp_file.name)
            return 1

        if audio_clip.Play():
            audio_clip.audio_player.AddCallback("Stop", lambda: os.unlink(temp_file.name))
            return 0

        os.unlink(temp_file.name)
        return 1

    async def _func(self, message: list[str], player):
        self.logger.debug("_func " + str(message))

        if self.check_disabled(player):
            return -1

        if not message[1]:
            return 1

        command = message[0]

        if not command.startswith("!tsay"):
            return 1

        target_lang = command[5:]
        tld = "com"

        if target_lang not in self.VALID_LANGUAGES:
            self.torchlight.SayPrivate(
                player, f"{{darkred}}[TranslateSay]{{default}} Language '{target_lang}' not supported."
            )
            return 1

        asyncio.ensure_future(self.TranslateAndSay(player, target_lang, tld, message[1]))
        return 0


class DECTalk(BaseCommand):
    async def Say(self, player: Player, message: str) -> int:
        message = "[:phoneme on]" + message
        temp_file = tempfile.NamedTemporaryFile(delete=False)
        temp_file.close()

        dectalk_path = os.path.abspath(self.torchlight.config.config.get("DECTalk", {}).get("Path", "dectalk"))
        dectalk_say_path = os.path.abspath(
            os.path.join(
                dectalk_path,
                self.torchlight.config.config.get("DECTalk", {}).get("SayFilename", "say"),
            )
        )
        subprocess_exec = await asyncio.create_subprocess_exec(
            dectalk_say_path,
            "-fo",
            temp_file.name,
            cwd=dectalk_path,
            stdin=asyncio.subprocess.PIPE,
        )
        await subprocess_exec.communicate(message.encode("utf-8", errors="ignore"))

        audio_clip = self.audio_manager.AudioClip(player, Path(temp_file.name).absolute().as_uri())
        if not audio_clip:
            os.unlink(temp_file.name)
            return 1

        if audio_clip.Play(None, "-af", "volume=10dB"):
            audio_clip.audio_player.AddCallback("Stop", lambda: os.unlink(temp_file.name))
            return 0

        os.unlink(temp_file.name)
        return 1

    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.check_disabled(player):
            return -1

        if not message[1]:
            return 1

        asyncio.ensure_future(self.Say(player, message[1]))
        return 0


class Stop(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))
        extra = ""
        if len(message) > 1:
            extra = message[1].strip()

        self.logger.info(f"Stop command called by {player.name}, extra='{extra}'")
        self.audio_manager.Stop(player, extra)
        return 0


class StopAll(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))
        required_level = self.get_config()["level"]
        player_level = player.admin.level
        if player_level < required_level:
            self.torchlight.SayPrivate(
                player,
                f"{{darkred}}[Torchlight]{{default}} This command requires level "
                f"{required_level} or higher. Your level is {player_level}.",
            )
            return 1
        count = len(self.audio_manager.audio_clips)
        self.audio_manager.StopAll()

        self.torchlight.SayChat(
            f"{{darkred}}[Torchlight]{{default}} All audio ({count} clips) stopped by {player.name}."
        )
        return 0


class Enable(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))

        if self.torchlight.disabled:
            if self.torchlight.disabled > player.admin.level:
                self.torchlight.SayPrivate(
                    player,
                    "You don't have access to enable torchlight, since it was disabled by a higher level user.",
                )
                return 1
            self.torchlight.SayChat(
                "Torchlight has been enabled for the duration of this map - Type !disable to disable it again."
            )

            self.torchlight.disabled = False
        else:
            self.torchlight.SayChat("Torchlight is already enabled.")

        return 0


class Disable(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        if not self.torchlight.disabled:
            if self.torchlight.disabled > player.admin.level:
                self.torchlight.SayPrivate(
                    player,
                    (
                        "You don't have access to disable torchlight"
                        ", since it was already disabled by a higher level user."
                    ),
                )
                return 1
            self.torchlight.SayChat(
                "Torchlight has been disabled for the duration of this map - Type !enable to enable it again."
            )
            self.torchlight.disabled = player.admin.level
        else:
            self.torchlight.SayChat("Torchlight is already disabled.")
        return 0


class AdminAccess(BaseCommand):
    def ReloadValidUsers(self) -> None:
        self.access_manager.Load()
        for player in self.player_manager.players:
            if player:
                admin_override = self.access_manager.get_admin(unique_id=player.unique_id)
                if admin_override is not None:
                    self.logger.info(f"{player.unique_id}: overriding admin with {admin_override}")
                    player.admin = admin_override

    async def _func(self, message: list[str], admin_player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))
        if not message[1]:
            return -1

        if message[1].lower() == "reload":
            self.ReloadValidUsers()
            self.torchlight.SayChat(f"Loaded access list with {len(self.access_manager.admins)} users".format())

        elif message[1].lower() == "save":
            self.access_manager.Save()
            self.torchlight.SayChat(f"Saved access list with {len(self.access_manager.admins)} users".format())

        # Modify access
        else:
            targeted_player: Player | None = None
            buffer = message[1]
            temp_buffer = buffer.find(" as ")
            if temp_buffer != -1:
                try:
                    reg_name, level_parsed = buffer[temp_buffer + 4 :].rsplit(" ", 1)
                except ValueError as e:
                    self.torchlight.SayChat(str(e))
                    return 1

                reg_name = reg_name.strip()
                level_parsed = level_parsed.strip()
                buffer = buffer[:temp_buffer].strip()
            else:
                try:
                    buffer, level_parsed = buffer.rsplit(" ", 1)
                except ValueError as e:
                    self.torchlight.SayChat(str(e))
                    return 2

                buffer = buffer.strip()
                level_parsed = level_parsed.strip()

            self.logger.info(f"Searching {buffer} to set his level to {level_parsed}")

            # Find user by User ID
            if buffer[0] == "#" and buffer[1:].isnumeric():
                targeted_player = self.player_manager.FindUserID(int(buffer[1:]))
            # Search user by name
            else:
                for player in self.player_manager.players:
                    if player and player.name.lower().find(buffer.lower()) != -1:
                        targeted_player = player
                        break

            if targeted_player is None:
                self.torchlight.SayChat(f"Couldn't find user: {buffer}")
                return 3

            if level_parsed.isnumeric() or (level_parsed.startswith("-") and level_parsed[1:].isdigit()):
                level = int(level_parsed)

                if level >= admin_player.admin.level:
                    self.torchlight.SayChat(
                        f"Trying to assign level {level}"
                        f", which is higher or equal than your level ({admin_player.admin.level})"
                    )
                    return 4

                if (
                    targeted_player.admin.level >= admin_player.admin.level
                    and admin_player.user_id != targeted_player.user_id
                ):
                    self.torchlight.SayChat(
                        f"Trying to modify level {targeted_player.admin.level},"
                        f" which is higher or equal than your level ({admin_player.admin.level})"
                    )
                    return 5

                if "Regname" in locals():
                    self.torchlight.SayChat(
                        f'Changed "{targeted_player.name}"({targeted_player.unique_id})'
                        f" as {targeted_player.admin.name} level/name"
                        f" from {targeted_player.admin.level} to {level} as {reg_name}"
                    )
                    targeted_player.admin.name = reg_name
                else:
                    self.torchlight.SayChat(
                        f'Changed "{targeted_player.name}"({targeted_player.unique_id})'
                        f" as {targeted_player.admin.name} level"
                        f" from {targeted_player.admin.level} to {level}"
                    )

                targeted_player.admin.level = level
                self.access_manager.set_admin(
                    unique_id=targeted_player.unique_id,
                    admin=targeted_player.admin,
                )
            else:
                if level_parsed == "revoke":
                    if targeted_player.admin.level >= admin_player.admin.level:
                        self.torchlight.SayChat(
                            f"Trying to revoke level {targeted_player.admin.level}"
                            f", which is higher or equal than your level ({admin_player.admin.level})"
                        )
                        return 6

                    self.torchlight.SayChat(
                        f'Removed "{targeted_player.name}"({targeted_player.unique_id}) from access list '
                        f"(was {targeted_player.admin.name} with level {targeted_player.admin.level})"
                    )
                    targeted_player.admin.name = "Revoked"
                    targeted_player.admin.level = 0
                    targeted_player.admin.unique_id = targeted_player.unique_id
                    self.access_manager.set_admin(
                        unique_id=targeted_player.unique_id,
                        admin=targeted_player.admin,
                    )
        return 0


class Reload(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))
        required_level = self.get_config()["level"]
        player_level = player.admin.level
        if player_level < required_level:
            self.torchlight.SayPrivate(
                player, f"This command requires level {required_level} or higher. Your level is {player_level}."
            )
            return 1

        self.logger.info(f"Reloading configuration by {player.name}")
        self.torchlight.Reload()
        self.torchlight.SayPrivate(
            player, "Torchlight configuration has been reloaded (config, triggers, access list)."
        )
        return 0


class Exec(BaseCommand):
    async def _func(self, message: list[str], player: Player) -> int:
        self.logger.debug(sys._getframe().f_code.co_name + " " + str(message))
        try:
            resp = ast.literal_eval(message[1])
        except Exception as e:
            self.torchlight.SayChat(f"Error: {str(e)}")
            return 1
        self.torchlight.SayChat(str(resp))
        return 0
